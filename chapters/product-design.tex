\chapter{Struttura principale e progettazione}\label{cap:struttura-progettazione}

\intro{In questo capitolo saranno  descritte le attività di progettazione e codifica dell'applicativo.
Inoltre verranno descritte le tecnologie utilizzate durante lo sviluppo del progetto, le scelte architetturali e i componenti sviluppati.
}

\section{Tecnologie utilizzate}\label{sec:tecnologie-utilizzate}

Di seguito viene data una panoramica delle tecnologie utilizzate durante lo sviluppo del progetto di stage.

\subsection{Frontend}\label{subsec:frontend}
\subsubsection{Vue.js}\label{subsubsec:vue}
Vue.js è un framework JavaScript progressivo e reattivo, utilizzato per lo sviluppo di interfacce utente dinamiche e moderne. 
Creato da Evan You, Vue.js è apprezzato per la sua semplicità d'uso e flessibilità. Con un sistema di reattività basato su un modello di oggetti e dipendenze, 
Vue.js rende facile il monitoraggio e l'aggiornamento automatico dell'interfaccia utente in base ai cambiamenti di stato dei dati. La sua architettura basata 
su componenti consente di organizzare il codice in moduli riutilizzabili e autonomi, semplificando la creazione di applicazioni complesse. 
Grazie alle direttive, è possibile arricchire il DOM con funzionalità reattive, mentre il sistema di routing agevola la creazione di single page applications. 
Con una crescita costante della comunità di sviluppatori, Vue.js è diventato un'opzione popolare nel mondo dello sviluppo frontend.
Per il mio progetto sono andato ad utilizzare la versione 3 di Vue.js, insieme allo script setup, che è una nuova sintassi per definire componenti progettata per semplificare la struttura del codice e migliorare la leggibilità.

\subsubsection{TypeScript}\label{subsubsec:TypeScript}
TypeScript è un linguaggio di programmazione open-source sviluppato da Microsoft. Si basa su JavaScript e offre tipizzazione statica opzionale, 
consentendo agli sviluppatori di specificare tipi per variabili, parametri di funzioni e oggetti. Questa caratteristica aiuta a individuare errori e a migliorare 
la manutenibilità del codice.\\
All'interno del mio progetto sono andato a creare per la parte frontend una cartella chiamata types che contiene un file TypeScript contenente tutti i tipi utilizzati all'interno del progetto.
\subsubsection{Vite.js}\label{subsubsec:vite}
Vite.js è un build tool utilizzato per lo sviluppo di applicazioni web. È stato creato da Evan You, lo stesso creatore di Vue.js, e si basa su rollup.js.
Vite.js è stato progettato per essere veloce, semplice da utilizzare e facile da configurare. La sua velocità è dovuta al fatto che utilizza la tecnica dell'ESM (ECMAScript Modules) 
che permette di caricare i moduli in modo asincrono, riducendo i tempi di compilazione e di hot-reload.
\subsubsection{Sass}\label{subsubsec:Sass}
Sass è un'estensione di CSS che offre funzionalità aggiuntive e avanzate per semplificare e organizzare il modo in cui viene scritto e gestito il codice CSS.
Può essere considerato un preprocessore CSS, in quanto viene compilato in CSS prima di essere interpretato dal browser. Sass inoltre permette di utilizzare funzionalità non disponibili in CSS nativo, offrendo una serie di funzioni, variabili, mixin e altro.\\
Insieme a Sass, ho utilizzato BEM, ovvero una metodologia di naming convention utilizzata nel mondo dello sviluppo web.

\subsection{Backend}\label{subsec:backend}
\subsubsection{Nest.js}\label{subsubsec:nest}
Nest.js è un framework per applicazioni server-side basato su Node.js. Si basa su Express.js e TypeScript ed è progettato per creare applicazioni scalabili e performanti.
Il framework NestJS combina concetti e caratteristiche provenienti da diversi paradigmi di sviluppo, tra cui la programmazione orientata agli oggetti (OOP), la programmazione funzionale e la programmazione reattiva.

\subsection{Altre tecnologie di supporto}\label{subsec:altre-tecnologie-di-supporto}
\subsubsection{Node.js}\label{subsubsec:node.js}
Node.js è un ambiente di runtime JavaScript open-source progettato per eseguire codice lato server. Per gestire le dipendenze del mio progetto,
ho deciso di utilizzare pnpm come gestore di pacchetti. Questa selezione ha portato a un miglior utilizzo delle risorse di sistema e ha notevolmente accelerato il processo di 
installazione delle dipendenze.
 \subsubsection{Pinia}\label{subsubsec:pinia}
Pinia è una libreria per la gestione dello stato per applicazioni Vue.js. Promuove l'uso di store modulari, ognuno dei quali gestisce uno stato specifico dell'applicazione.
\subsubsection{Vue router}\label{subsubsec:vue-router}
Vue-router è una libreria per la gestione delle route per le applicazione Vue.js. Permette di definire le route dell'applicazione e di navigare tra le pagine.

\subsection{Versionamento}\label{subsec:versionamento}
\subsubsection{Git}\label{subsubsec:git}
Git è un sistema di controllo versione distribuito e altamente flessibile, utile per tenere traccia delle modifiche apportate al codice sorgente durante lo sviluppo di un progetto software.
\subsubsection{CodeCommit}\label{subsubsec:CodeCommit}
AWS CodeCommit rappresenta un servizio di hosting di repository altamente scalabile, che è gestito all'interno dell'ecosistema di Amazon Web Services (AWS). 
Con CodeCommit, è possibile ospitare repository Git privati in un ambiente sicuro e flessibile.

\subsection{Verifica}\label{subsec:verifica}
\subsubsection{ESLint}\label{subsubsec:eslint}
ESLint è uno strumento open-source ampiamente utilizzato per l'analisi statica del codice JavaScript. Esso permette di identificare e segnalare potenziali errori o pratiche non conformi durante la fase di sviluppo.
\subsubsection{Vitest}\label{subsubsec:vitest}
Vitest è un framework per l'implementazione di test di unità, utilizzato maggiormente in progetti Vue.js.
Usato in coppia con Vite permette di eseguire test di unità in modo più veloce e semplice.

\subsection{Librerie esterne utilizzate}\label{subsec:librerie-esterne}
\subsubsection{THRON Components}\label{subsubsec:thron-components}
Libreria THRON contenente i componenti del design system aziendale. Questa libreria è stata utilizzata per la creazione di componenti comuni come bottoni, del portale.
\subsubsection{Azure MSAL}\label{subsubsec:azure-MSAL}
Azure MSAL è una libreria che permette di integrare il login con Azure Active Directory all'interno di un'applicazione web.
\subsubsection{Swagger UI}\label{subsubsec:swagger-ui}
Swagger UI è una libreria open-source progettata per semplificare la visualizzazione e l'interazione con la documentazione delle API.

\section{Struttura principale del sistema}
Il sistema è composto da due principali sezioni:
\begin{itemize}
  \item Frontend, ovvero l'interfaccia utente dell'applicazione web che permette all'utilizzatore di interagire con il sistema. È responsabile di presentare i contenuti in modo visivamente attraente e interattivo, consentendo agli utenti di navigare, inserire dati e svolgere azioni specifiche. Per lo
  sviluppo di questa parte del sistema è stato utilizzato il framework Vue.js;
  \item Backend, ovvero la parte del sistema che elabora le richieste provenienti dal frontend e restituisce i risultati. È responsabile della gestione dei dati e della logica di business.
  Lo sviluppo di questa parte del sistema è stato realizzato utilizzando il framework Nest.js. 
\end{itemize}

\subsection{Ambienti di sviluppo}
Gli ambienti di staging sono ambienti di test che vengono utilizzati per testare le funzionalità dell'applicazione prima di rilasciarla in produzione.
% A livello aziendale sono stati definiti tutte e tre come ambienti di staging e sono stati denominati come segue:
A livello aziendale sono stati definiti tre ambienti di cui i primi due di staging, denominati come segue:
\begin{itemize}
  \item \textbf{Development}: consente di validare a livello tecnico le funzionalità;
  \item \textbf{Quality}: consente di validare a livello funzionale o di implementazione delle funzionalità;
  \item \textbf{Production}: ambiente di produzione in cui viene rilasciata la funzionalità.
\end{itemize}

\subsection{Configurazione ambiente del progetto}
Il progetto di stage, necessita di cartelle per la configurazione dell'ambiente di sviluppo, per la configurazione del progetto e per la configurazione del deploy.
Più precisamente, il progetto segue la seguente struttura:

\subsubsection*{\emph{Buildspec}}
La cartella buildspec contiene i file di configurazione per la build dell'applicazione su AWS CodeBuild.
Questo è il primo step del processo di deploy, in quanto viene eseguito la build sia del middleware che del portale.
La cartella è formata a sua volta da tre file: buildspec\_development, buildspec\_quality e buildspec\_production. 
Ognuno di questi file configura la build dell'applicazione in base all'ambiente di deploy.\\
Successivamente dopo aver effettuato tutti i comandi specificati nei file buildspec, inizia lo step di deploy, specificato nella cartella Infra.
Ognuno dei file buildspec è un file YAML, che è formato dalle seguenti sezioni:
\begin{itemize}
  \item La sezione env dove vengono specificate le variabili d'ambiente utilizzate nel progetto;
  \item La sezione di pre-build dove vengono specificati i comandi da eseguire prima della build;
  \item La sezione di build dove vengono specificati i comandi per la build del portale e del middleware.
\end{itemize}

\subsubsection*{\emph{Infra}}
La cartella Infra contiene i file di configurazione per il deploy dell'applicazione su AWS. È scritta utilizzando il linguaggio di programmazione Python.\\
La cartella è formata da due file: app.py e stack.py. Il primo file contiene la configurazione per il deploy dell'applicazione, mentre il secondo file contiene la configurazione per il deploy dell'infrastruttura.\\
Per quanto riguarda l'infrastruttura del progetto, sono andato ad utilizzare e a configurare due costrutti, anche chiamati CDK Constructs o semplicemente Constructs, che sono delle classi che rappresentano un componente dell'infrastruttura.
Il primo costrutto si chiama THRONCloudFrontDistribution e consente di accelerare la distribuzione dei contenuti web statici e dinamici, come file .html, .css, .js e immagini, agli utenti.
In breve questo costrutto genera il template di AWS CloudFront ed esegui il deploy degli asset statici su un bucket S3.\\
Il secondo costrutto che sono andato ad utilizzare si chiama THRONDockerLambda e consente di creare una funzione lambda in cui il gestore è un'immagine docker.
Nel caso del mio progetto, mi è servito per creare un lambda che una volta invocata avvia un docker con all'interno il progetto backend.\\

\subsection*{\emph{Middleware}}
La cartella Middleware contiene il progetto backend in Nest-js. Nello specifico la cartella è formata dalle seguenti sezioni:
\begin{itemize}
  \item La cartella src che contiene il codice sorgente dell'applicazione, dove vengono specificati i vari endpoint che utilizzo sulla parte frontend, lo script per il setting
  della lambda, una cartella con gli helpers e la cartella del middleware.
  \item La cartella test che contiene i test di unità dell'applicazione;
  \item File env che contiene le variabili d'ambiente utilizzate nel progetto;
  \item Una cartella node\_modules che contiene le dipendenze del progetto.
\end{itemize}
\subsection*{\emph{Portal}}
La cartella portal contiene il progetto frontend in vue-js. Nello specifico la cartella è formata dalle seguenti sezioni:
\begin{itemize}
  \item La cartella public che contiene il file index.html, che è il file principale dell'applicazione;
  \item Una cartella node\_modules che contiene le dipendenze del progetto;
  \item La cartella src che contiene il codice sorgente dell'applicazione, dove vengono specificati i vari componenti che utilizzo, i vari store, i vari router e i vari utils.
  \item File env che contiene le variabili d'ambiente utilizzate nel progetto.
\end{itemize}

\subsection*{\emph{Dockerfile}}
Il file Dockerfile è un file docker che contiene le istruzioni per creare un'immagine che verrà utilizzata per eseguire il middleware all'interno di una lambda.\\
Utilizzando la struttura Dockerfile, sono andato a creare un ambiente isolato in cui il middleware può essere configurato e utilizzato come parte della mia funzione 
lambda. Quando la funzione viene invocata, avvia il Docker container ed esegue il middleware all'interno dell'ambiente containerizzato, 
garantendo che esso sia parte integrante dell'applicazione serverless.

% buildspec -> cartella con configuraazione dei build, per codebuild primo step, builda sia portal che il middleware
% quando finsice la build ti attacca allo step di deploy, definite in infra. 
% PEr il portale costrutto cloudfrontdistribution -> genera il template di aws clodfront e esegue il deploy degli asset statici su s3. S3 container
% Secondo costrutto -> throndockerlambda e questo crea la lambda con quando viene invocata avvia un docker con all'interno il mio middleware.

\section{Progettazione}\label{sec:progettazione}

\subsection{Architettura frontend}\label{subsec:architettura-front-end}
\subsubsection{Architettura Vue.js}\label{subsubsec:architettura-vue.js}
Vue.js è un framework utilizzato nelle single page application, che permette di definire le pagine web in modo modulare, utilizzando componenti riutilizzabili.
I componenti costituiscono la base dell'architettura di Vue. Essi rappresentano una parte isolata dell'interfaccia, che può contenere il proprio modello, i propri stili e la propria logica, infatti ogni componente ha il proprio
template scritto in HTML, il proprio script scritto nel mio caso in TypeScript e i propri stili scritti nel mio caso in scss.
Come già accennato in precedenza, i componenti sono riutilizzabili all'interno di un'applicazione e possono essere combinati tra loro per creare gerarchie di interfaccie ancora più complesse.\\

L'architettura di Vue.js è basata sul pattern architetturale MVVM (Model-View-ViewModel), che è una variante del pattern MVC (Model-View-Controller), dove:
\begin{itemize}
  \item \textbf{Model}: rappresenta lo stato, i dati e le regole di business dell'applicazione, che gestiscono l'accesso e la modifica di tali dati. Lo stato viene definito tramite l'uso
  di particolari variabili di tipo reattivo, che permettono di aggiornare automaticamente la view associata in caso di modifiche;
  \item \textbf{View}: è l'interfaccia utente, che visualizza i dati contenuti nel model e si occupa di reagire agli input dell'utente. La view è definita utilizzando i template Vue.js e viene reattivamente aggiornata in base ai cambiamenti del modello. La vista viene definita utilizzando un template, ovvero una direttiva dell'HTML, arricchita con alcune direttive Vue.js. 
  Queste particolari direttive permettono di collegare elementi del DOM a proprietà o metodi del modello, in modo che la view possa reagire agli input dell'utente e aggiornare automaticamente lo stato dell'applicazione;
  \item \textbf{ViewModel}: è l'intermediario tra la view e  il model. Il ViewModel gestisce la logica dell'interfaccia utente e mantiene lo stato dell'applicazione sincronizzato con la view.
  Il ViewModel è rappresentato da un componente Vue.js, infatti esso è un'istanza che collega il modello e la vista. All'interno di un componente è possibile definire metodi, proprietà 
  computate, metodi del ciclo di vita, gestione di eventi e molte altre funzionalità. Questo consente di definire la logica di presentazione e di manipolare i dati all'interno di un contesto definito.
\end{itemize}

In breve, l'architettura è incentrata sulla creazione e utilizzo di componenti riutilizzabili che al loro interno incorporano sia il modello che la vista. Un aspetto che rende Vue.js
diverso da altri framework è proprio il concetto di reattività, infatti Vue.js è in grado di rilevare automaticamente le dipendenze tra i componenti, in modo da poter aggiornare automaticamente l'interfaccia utente.

\subsection{Architettura backend}\label{subsec:architettura-backend}
\subsubsection{Architettura Nest.js}\label{subsubsec:architettura-nest.js}
L'architettura di Nest.js si basa su diversi principi chiave e concetti fondamentali che lo rendono un framework efficace per la creazione di applicazioni server-side.
La caratteristica principale di Nest.js è la modularità, che promuove la suddivisione dell'applicazione in moduli, consentendo di organizzare il codice in unità funzionali e riutilizzabili.\\
Di seguito i concetti base su cui si basa l'architettura:
\begin{itemize}
  \item \textbf{Module}: rappresenta un'unità organizzativa dell'applicazione che contiene un gruppo di elementi correlati come controller, service e provider. Questa struttura modulare 
  favorisce la separazione delle responsabilità rendendo il codice più leggibile;
  \item \textbf{Controller}: sono interfacce tra la rete e la logica dell'applicazione responsabili della gestione delle richieste HTTP in ingresso. Ogni controller è associato a un percorso specifico e a uno o più metodi che rappresentano le diverse azioni eseguibili sul percorso;
  \item \textbf{Service}: contiene la logica di business dell'applicazione. I service sono responsabili della gestione dei dati e dell'interazione con le risorse esterne.
\end{itemize}